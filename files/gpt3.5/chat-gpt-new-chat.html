<!DOCTYPE html><html><head>  <meta charset="utf-8"/>  <title>Chat GPT: New chat</title>  <meta name="generator" content="chatGPT Saving Bookmark"/><style>body {  background-color: rgb(32,33,35);  color: rgb(236,236,241);  font-size: 16px;  font-family: sans-serif;  line-height: 28px;  margin: 0;}body > .w-full {  padding: 30px;}/* prompt */body > .w-full:nth-child(2n+1) {  background: rgb(52,53,65);}/* response */body > .w-full:nth-child(2n+2) {  background: rgb(68,70,84);}a, a:visited {  color: #7792cd;}pre {  margin: 0 0 1em 0;  display: inline-block;  width: 100%;}pre code.hljs {  margin-bottom: 1em;  border-radius: 5px;}.whitespace-pre-wrap {  white-space: pre-wrap;}.flex-col {  max-width: 850px;  margin: 0px auto;}*, :after, :before {    border: 0 solid #d9d9e3;    box-sizing: border-box;}table {    border-collapse: collapse;    border-color: inherit;    text-indent: 0;}.markdown table {    --tw-border-spacing-x: 0px;    --tw-border-spacing-y: 0px;    border-collapse: separate;    border-spacing: var(--tw-border-spacing-x) var(--tw-border-spacing-y);    width: 100%}.markdown th {    background-color: rgba(236,236,241,.2);    border-bottom-width: 1px;    border-left-width: 1px;    border-top-width: 1px;    padding: .25rem .75rem}.markdown th:first-child {    border-top-left-radius: .375rem}.markdown th:last-child {    border-right-width: 1px;    border-top-right-radius: .375rem}.markdown td {    border-bottom-width: 1px;    border-left-width: 1px;    padding: .25rem .75rem}.markdown td:last-child {    border-right-width: 1px}.markdown tbody tr:last-child td:first-child {    border-bottom-left-radius: .375rem}.markdown tbody tr:last-child td:last-child {    border-bottom-right-radius: .375rem}/* chatGPT code color theme */code.hljs,code[class*=language-],pre[class*=language-]{word-wrap:normal;background:none;color:#fff;-webkit-hyphens:none;hyphens:none;line-height:1.5;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}pre[class*=language-]{border-radius:.3em;overflow:auto}:not(pre)>code.hljs,:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em;white-space:normal}.hljs-comment{color:hsla(0,0%,100%,.5)}.hljs-meta{color:hsla(0,0%,100%,.6)}.hljs-built_in,.hljs-class .hljs-title{color:#e9950c}.hljs-doctag,.hljs-formula,.hljs-keyword,.hljs-literal{color:#2e95d3}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#00a67d}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#df3079}.hljs-bullet,.hljs-link,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#f22c3d}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#a9aec1}.token.punctuation{color:#fefefe}.token.constant,.token.deleted,.token.property,.token.symbol,.token.tag{color:#ffa07a}.token.boolean,.token.number{color:#00e0e0}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#abe338}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url,.token.variable{color:#00e0e0}.token.atrule,.token.attr-value,.token.function{color:gold}.token.keyword{color:#00e0e0}.token.important,.token.regex{color:gold}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}@media screen and (-ms-high-contrast:active){code[class*=language-],pre[class*=language-]{background:window;color:windowText}:not(pre)>code[class*=language-],pre[class*=language-]{background:window}.token.important{background:highlight;color:window;font-weight:400}.token.atrule,.token.attr-value,.token.function,.token.keyword,.token.operator,.token.selector{font-weight:700}.token.attr-value,.token.comment,.token.doctype,.token.function,.token.keyword,.token.operator,.token.property,.token.string{color:highlight}.token.attr-value,.token.url{font-weight:400}}/* style of the code snippets */.rounded-md {    border-radius: 0.375rem;}.mb-4 {    margin-bottom: 1rem;}.p-4 {    padding: 1rem;}.py-2 {    padding-bottom: 0.5rem;    padding-top: 0.5rem;}.px-4 {    padding-left: 1rem;    padding-right: 1rem;}.text-xs {    font-size: .75rem;    line-height: 1rem;}.bg-black {    --tw-bg-opacity: 1;    background-color: rgba(0,0,0,var(--tw-bg-opacity));}.text-gray-200 {    --tw-text-opacity: 1;    color: rgba(217,217,227,var(--tw-text-opacity));}.bg-gray-800 {    --tw-bg-opacity: 1;    background-color: rgba(52,53,65,var(--tw-bg-opacity));}.rounded-t-md {    border-top-left-radius: 0.375rem;    border-top-right-radius: 0.375rem;}code.hljs, code[class*=language-], pre[class*=language-] {    word-wrap: normal;    background: none;    color: #fff;    -webkit-hyphens: none;    hyphens: none;    line-height: 1.5;    tab-size: 4;    text-align: left;    white-space: pre;    word-break: normal;    word-spacing: normal;}.prose :where(code):not(:where([class~=not-prose] *)) {    color: var(--tw-prose-code);    font-size: .875em;    font-weight: 600;}.prose :where(pre):not(:where([class~=not-prose] *)) {    background-color: transparent;    border-radius: 0.375rem;    color: currentColor;    font-size: .875em;    font-weight: 400;    line-height: 1.7142857;    margin: 0;    overflow-x: auto;    padding: 0;}.prose :where(pre code):not(:where([class~=not-prose] *)) {    background-color: transparent;    border-radius: 0;    border-width: 0;    color: inherit;    font-family: inherit;    font-size: inherit;    font-weight: inherit;    line-height: inherit;    padding: 0;}.\!whitespace-pre {    white-space: pre!important;}.overflow-y-auto {    overflow-y: auto;}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"/></head><body><div class="flex w-full items-center justify-center gap-1 border-b border-black/10 bg-gray-50 p-3 text-gray-500 dark:border-gray-900/50 dark:bg-gray-700 dark:text-gray-300">Model: Default (GPT-3.5)</div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">mean squared error</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>Mean squared error (MSE) is a statistical metric used to measure the average squared difference between the predicted values and the actual values. It is commonly used to evaluate the performance of a regression model.</p><p>MSE is calculated by taking the average of the squared differences between the predicted values and the actual values. This is achieved by first finding the difference between each predicted value and</p></div></div></div><div class="flex justify-between lg:block"></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">i did a MC to generate a bunch of MLEs. i've estimating bias, i have the estimates, and i know true param... should i estimate MSE too?</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>Yes, it would be a good idea to estimate the mean squared error (MSE) of your maximum likelihood estimator (MLE) as well, in addition to estimating its bias. The MSE is a measure of the overall accuracy and precision of your MLE, taking into account both its bias and its variance.</p><p>To estimate the MSE of your MLE, you can calculate the average squared difference between the estimated values and the true parameter values over multiple Monte Carlo simulations. This will give you an idea of how much the estimated values are expected to vary from the true values due to both bias and random error.</p><p>By estimating the bias and MSE of your MLE, you can get a more complete picture of its performance and assess whether it is a suitable estimator for your data and model. If the bias and/or MSE are too high, you may need to consider using a different estimator or adjusting your model to improve its accuracy.</p></div></div></div><div class="flex justify-between lg:block"></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">how in r?</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>To estimate the mean squared error (MSE) of your maximum likelihood estimator (MLE) in R, you can use the following steps:</p><ol><li><p>Generate a large number of Monte Carlo simulations of your data and estimate the parameters using MLE for each simulation.</p></li><li><p>Calculate the bias and MSE for each parameter estimate using the true parameter values and the estimated parameter values.</p></li><li><p>Take the average of the squared differences between the true parameter values and the estimated parameter values to get an estimate of the MSE.</p></li></ol><p>Here is an example code that demonstrates these steps for a simple linear regression model:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>scss</span></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-scss"># Generate simulated data
set<span class="hljs-selector-class">.seed</span>(<span class="hljs-number">123</span>)
x &lt;- <span class="hljs-built_in">rnorm</span>(<span class="hljs-number">100</span>)
y &lt;- <span class="hljs-number">2</span> + <span class="hljs-number">3</span>*x + <span class="hljs-built_in">rnorm</span>(<span class="hljs-number">100</span>)

# Define likelihood function for linear regression model
log_likelihood &lt;- <span class="hljs-built_in">function</span>(theta, x, y) {
  beta0 &lt;- theta<span class="hljs-selector-attr">[1]</span>
  beta1 &lt;- theta<span class="hljs-selector-attr">[2]</span>
  sigma &lt;- theta<span class="hljs-selector-attr">[3]</span>
  n &lt;- <span class="hljs-built_in">length</span>(y)
  -n/<span class="hljs-number">2</span>*<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>*pi*sigma^<span class="hljs-number">2</span>) - <span class="hljs-built_in">sum</span>((y - beta0 - beta1*x)^<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*sigma^<span class="hljs-number">2</span>)
}

# Define function to estimate MLEs for linear regression model
mle_estimate &lt;- <span class="hljs-built_in">function</span>(x, y) {
  nll &lt;- <span class="hljs-built_in">function</span>(theta) <span class="hljs-built_in">-log_likelihood</span>(theta, x, y)
  start &lt;- <span class="hljs-built_in">c</span>(mean(y), <span class="hljs-number">1</span>, <span class="hljs-built_in">sd</span>(y))
  fit &lt;- <span class="hljs-built_in">optim</span>(start, nll, hessian = TRUE)
  <span class="hljs-built_in">list</span>(beta0 = fit$par[<span class="hljs-number">1</span>], beta1 = fit$par[<span class="hljs-number">2</span>], sigma = fit$par[<span class="hljs-number">3</span>],
       hessian = fit$hessian)
}

# Generate multiple simulations of data and estimate parameters using MLE
n_sims &lt;- <span class="hljs-number">1000</span>
theta_true &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, sd(y))
theta_estimates &lt;- <span class="hljs-built_in">matrix</span>(<span class="hljs-number">0</span>, nrow = n_sims, ncol = <span class="hljs-number">3</span>)
for (i in <span class="hljs-number">1</span>:n_sims) {
  y_sim &lt;- <span class="hljs-number">2</span> + <span class="hljs-number">3</span>*x + <span class="hljs-built_in">rnorm</span>(<span class="hljs-number">100</span>)
  theta_estimates<span class="hljs-selector-attr">[i, ]</span> &lt;- <span class="hljs-built_in">unlist</span>(mle_estimate(x, y_sim))
}

# Calculate bias and MSE for each parameter estimate
bias &lt;- <span class="hljs-built_in">colMeans</span>(theta_estimates - theta_true)
mse &lt;- <span class="hljs-built_in">colMeans</span>((theta_estimates - theta_true)^<span class="hljs-number">2</span>)

# Estimate overall MSE
overall_mse &lt;- <span class="hljs-built_in">mean</span>(mse)
</code></div></div></pre><p>In this code, we first generate simulated data for a linear regression model. We then define a likelihood function and a function to estimate the MLEs for the model. We use these functions to generate multiple simulations of data and estimate the parameters using MLE for each simulation. We then calculate the bias and MSE for each parameter estimate, and estimate the overall MSE by taking the mean of the MSE values.</p></div></div></div><div class="flex justify-between lg:block"></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">what else can i do with these MC MLEs?</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>There are several other things you can do with the Monte Carlo (MC) MLEs that you have generated:</p><ol><li><p>Visualize the distribution of the MLE estimates: You can create histograms or density plots to visualize the distribution of the MLE estimates across the Monte Carlo simulations. This can give you an idea of the variability and skewness of the estimates.</p></li><li><p>Calculate confidence intervals: You can calculate confidence intervals for the MLE estimates using the bootstrap or other resampling methods. This can help you to understand the precision of your estimates and the uncertainty around them.</p></li><li><p>Check for convergence: You can examine the distribution of the MLE estimates over time or over iterations within each simulation to check for convergence. If the estimates are not converging or are showing a lot of variability, you may need to re-examine your model or consider using a different estimation method.</p></li><li><p>Compare different models: You can generate MC MLEs for different models and compare their performance using metrics like the Akaike Information Criterion (AIC) or the Bayesian Information Criterion (BIC). This can help you to identify the best-fitting model for your data.</p></li><li><p>Evaluate model assumptions: You can use the MC MLEs to evaluate the assumptions of your model, such as the normality of the errors or the homogeneity of variance. You can do this by examining the distribution of the residuals or by comparing the MLE estimates for different subgroups of the data.</p></li></ol><p>Overall, MC MLEs can be a useful tool for evaluating and improving the performance of your models. By examining the distribution of the estimates and checking for convergence, you can gain insight into the properties of your model and identify areas for improvement.</p></div></div></div><div class="flex justify-between lg:block"></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">what's coverage probability?</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>Coverage probability is a statistical concept that refers to the proportion of confidence intervals (CIs) that include the true population parameter. In other words, it is the probability that a randomly selected CI will cover the true value of the parameter.</p><p>For example, if we construct 100 confidence intervals using a particular method and assume that the true parameter value is known, we can count how many of those intervals actually include the true parameter value. The coverage probability is then the proportion of intervals that cover the true parameter value.</p><p>Coverage probability is an important measure of the performance of a statistical method for constructing confidence intervals. Ideally, we would like the coverage probability to match the nominal level of the CI, which is usually set to a particular value (such as 95% or 99%) based on the desired level of confidence. If the coverage probability is significantly different from the nominal level, it can indicate that the method is biased or that the assumptions underlying the method are not being met.</p><p>Thus, coverage probability is a way to assess the accuracy and reliability of statistical inference methods, such as confidence intervals or hypothesis tests. A method with high coverage probability is generally preferred, as it is more likely to produce accurate and reliable results.</p></div></div></div><div class="flex justify-between lg:block"></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">r code for coverage prob. i already have a bunch of MLEs</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>To calculate the coverage probability of confidence intervals for your maximum likelihood estimators (MLEs) in R, you can use the following steps:</p><ol><li><p>Choose a confidence level for your intervals. This is typically set to 95% or 99%.</p></li><li><p>Define a function that constructs confidence intervals for your parameter estimates based on the chosen confidence level.</p></li><li><p>Generate a large number of Monte Carlo simulations of your data and estimate the parameters using MLE for each simulation.</p></li><li><p>For each simulation, construct a confidence interval for each parameter estimate using your function from step 2.</p></li><li><p>Count the number of intervals that cover the true parameter values, and divide by the total number of simulations to obtain the coverage probability.</p></li></ol><p>Here is an example code that demonstrates these steps for a simple linear regression model:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>scss</span></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-scss"># Generate simulated data
set<span class="hljs-selector-class">.seed</span>(<span class="hljs-number">123</span>)
x &lt;- <span class="hljs-built_in">rnorm</span>(<span class="hljs-number">100</span>)
y &lt;- <span class="hljs-number">2</span> + <span class="hljs-number">3</span>*x + <span class="hljs-built_in">rnorm</span>(<span class="hljs-number">100</span>)

# Define likelihood function for linear regression model
log_likelihood &lt;- <span class="hljs-built_in">function</span>(theta, x, y) {
  beta0 &lt;- theta<span class="hljs-selector-attr">[1]</span>
  beta1 &lt;- theta<span class="hljs-selector-attr">[2]</span>
  sigma &lt;- theta<span class="hljs-selector-attr">[3]</span>
  n &lt;- <span class="hljs-built_in">length</span>(y)
  -n/<span class="hljs-number">2</span>*<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>*pi*sigma^<span class="hljs-number">2</span>) - <span class="hljs-built_in">sum</span>((y - beta0 - beta1*x)^<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*sigma^<span class="hljs-number">2</span>)
}

# Define function to estimate MLEs for linear regression model
mle_estimate &lt;- <span class="hljs-built_in">function</span>(x, y) {
  nll &lt;- <span class="hljs-built_in">function</span>(theta) <span class="hljs-built_in">-log_likelihood</span>(theta, x, y)
  start &lt;- <span class="hljs-built_in">c</span>(mean(y), <span class="hljs-number">1</span>, <span class="hljs-built_in">sd</span>(y))
  fit &lt;- <span class="hljs-built_in">optim</span>(start, nll, hessian = TRUE)
  <span class="hljs-built_in">list</span>(beta0 = fit$par[<span class="hljs-number">1</span>], beta1 = fit$par[<span class="hljs-number">2</span>], sigma = fit$par[<span class="hljs-number">3</span>],
       hessian = fit$hessian)
}

# Define function to construct confidence intervals for linear regression parameters
confint_func &lt;- <span class="hljs-built_in">function</span>(theta, se, alpha) {
  lower &lt;- theta - <span class="hljs-built_in">qt</span>(alpha/<span class="hljs-number">2</span>, df = Inf)*se
  upper &lt;- theta + <span class="hljs-built_in">qt</span>(alpha/<span class="hljs-number">2</span>, df = Inf)*se
  <span class="hljs-built_in">return</span>(c(lower, upper))
}

# Generate multiple simulations of data and estimate parameters using MLE
n_sims &lt;- <span class="hljs-number">1000</span>
theta_true &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, sd(y))
theta_estimates &lt;- <span class="hljs-built_in">matrix</span>(<span class="hljs-number">0</span>, nrow = n_sims, ncol = <span class="hljs-number">3</span>)
for (i in <span class="hljs-number">1</span>:n_sims) {
  y_sim &lt;- <span class="hljs-number">2</span> + <span class="hljs-number">3</span>*x + <span class="hljs-built_in">rnorm</span>(<span class="hljs-number">100</span>)
  theta_estimates<span class="hljs-selector-attr">[i, ]</span> &lt;- <span class="hljs-built_in">unlist</span>(mle_estimate(x, y_sim))
}

# Calculate confidence intervals for each parameter estimate
alpha &lt;- <span class="hljs-number">0.05</span> # <span class="hljs-number">95%</span> confidence level
se_estimates &lt;- <span class="hljs-built_in">sqrt</span>(diag(solve(-apply(theta_estimates, <span class="hljs-number">2</span>, log_likelihood))))
ci_estimates &lt;- <span class="hljs-built_in">matrix</span>(<span class="hljs-number">0</span>, nrow = n_sims, ncol = <span class="hljs-number">6</span>)
for (i in <span class="hljs-number">1</span>:n_sims) {
  ci_estimates<span class="hljs-selector-attr">[i, 1:2]</span> &lt;- <span class="hljs-built_in">confint_func</span>(theta_estimates[i, <span class="hljs-number">1</span>], se_estimates[<span class="hljs-number">1</span>], alpha)
  ci_estimates<span class="hljs-selector-attr">[i, 3:4]</span> &lt;- <span class="hljs-built_in">confint_func</span>(theta_estimates[i, <span class="hljs-number">2</span>], se_estimates[<span class="hljs-number">2</span>], alpha)
  ci_estimates<span class="hljs-selector-attr">[i, 5:6]</span> &lt;- <span class="hljs-built_in">confint_func</span>(theta_estimates[i, <span class="hljs-number">3</span>], se_estimates[<span class="hljs-number">3</span>], alpha)
}

# Calculate coverage probability for each parameter estimate
coverage_prob &lt;- <span class="hljs-built_in">colSums</span>((ci_estimates[, <span class="hljs-number">1</span>:<span class="hljs-number">2</span>] &lt; theta_true[<span class="hljs-number">1</span>]) &amp; (ci_estimates[, <span class="hljs-number">3</span>:<span class="hljs-number">4</span>] &gt; theta_true[<span class="hljs-number">2</span>]) &amp;
                          (ci_est
</code></div></div></pre></div></div></div><div class="flex justify-between lg:block"></div></div></div></div></body></html>