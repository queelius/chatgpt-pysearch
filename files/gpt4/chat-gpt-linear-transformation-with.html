<!DOCTYPE html><html><head>  <meta charset="utf-8"/>  <title>Chat GPT: Linear transformation with %*%</title>  <meta name="generator" content="chatGPT Saving Bookmark"/><style>body {  background-color: rgb(32,33,35);  color: rgb(236,236,241);  font-size: 16px;  font-family: sans-serif;  line-height: 28px;  margin: 0;}body > .w-full {  padding: 30px;}/* prompt */body > .w-full:nth-child(2n+1) {  background: rgb(52,53,65);}/* response */body > .w-full:nth-child(2n+2) {  background: rgb(68,70,84);}a, a:visited {  color: #7792cd;}pre {  margin: 0 0 1em 0;  display: inline-block;  width: 100%;}pre code.hljs {  margin-bottom: 1em;  border-radius: 5px;}.whitespace-pre-wrap {  white-space: pre-wrap;}.flex-col {  max-width: 850px;  margin: 0px auto;}*, :after, :before {    border: 0 solid #d9d9e3;    box-sizing: border-box;}table {    border-collapse: collapse;    border-color: inherit;    text-indent: 0;}.markdown table {    --tw-border-spacing-x: 0px;    --tw-border-spacing-y: 0px;    border-collapse: separate;    border-spacing: var(--tw-border-spacing-x) var(--tw-border-spacing-y);    width: 100%}.markdown th {    background-color: rgba(236,236,241,.2);    border-bottom-width: 1px;    border-left-width: 1px;    border-top-width: 1px;    padding: .25rem .75rem}.markdown th:first-child {    border-top-left-radius: .375rem}.markdown th:last-child {    border-right-width: 1px;    border-top-right-radius: .375rem}.markdown td {    border-bottom-width: 1px;    border-left-width: 1px;    padding: .25rem .75rem}.markdown td:last-child {    border-right-width: 1px}.markdown tbody tr:last-child td:first-child {    border-bottom-left-radius: .375rem}.markdown tbody tr:last-child td:last-child {    border-bottom-right-radius: .375rem}/* chatGPT code color theme */code.hljs,code[class*=language-],pre[class*=language-]{word-wrap:normal;background:none;color:#fff;-webkit-hyphens:none;hyphens:none;line-height:1.5;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}pre[class*=language-]{border-radius:.3em;overflow:auto}:not(pre)>code.hljs,:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em;white-space:normal}.hljs-comment{color:hsla(0,0%,100%,.5)}.hljs-meta{color:hsla(0,0%,100%,.6)}.hljs-built_in,.hljs-class .hljs-title{color:#e9950c}.hljs-doctag,.hljs-formula,.hljs-keyword,.hljs-literal{color:#2e95d3}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#00a67d}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#df3079}.hljs-bullet,.hljs-link,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#f22c3d}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#a9aec1}.token.punctuation{color:#fefefe}.token.constant,.token.deleted,.token.property,.token.symbol,.token.tag{color:#ffa07a}.token.boolean,.token.number{color:#00e0e0}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#abe338}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url,.token.variable{color:#00e0e0}.token.atrule,.token.attr-value,.token.function{color:gold}.token.keyword{color:#00e0e0}.token.important,.token.regex{color:gold}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}@media screen and (-ms-high-contrast:active){code[class*=language-],pre[class*=language-]{background:window;color:windowText}:not(pre)>code[class*=language-],pre[class*=language-]{background:window}.token.important{background:highlight;color:window;font-weight:400}.token.atrule,.token.attr-value,.token.function,.token.keyword,.token.operator,.token.selector{font-weight:700}.token.attr-value,.token.comment,.token.doctype,.token.function,.token.keyword,.token.operator,.token.property,.token.string{color:highlight}.token.attr-value,.token.url{font-weight:400}}/* style of the code snippets */.rounded-md {    border-radius: 0.375rem;}.mb-4 {    margin-bottom: 1rem;}.p-4 {    padding: 1rem;}.py-2 {    padding-bottom: 0.5rem;    padding-top: 0.5rem;}.px-4 {    padding-left: 1rem;    padding-right: 1rem;}.text-xs {    font-size: .75rem;    line-height: 1rem;}.bg-black {    --tw-bg-opacity: 1;    background-color: rgba(0,0,0,var(--tw-bg-opacity));}.text-gray-200 {    --tw-text-opacity: 1;    color: rgba(217,217,227,var(--tw-text-opacity));}.bg-gray-800 {    --tw-bg-opacity: 1;    background-color: rgba(52,53,65,var(--tw-bg-opacity));}.rounded-t-md {    border-top-left-radius: 0.375rem;    border-top-right-radius: 0.375rem;}code.hljs, code[class*=language-], pre[class*=language-] {    word-wrap: normal;    background: none;    color: #fff;    -webkit-hyphens: none;    hyphens: none;    line-height: 1.5;    tab-size: 4;    text-align: left;    white-space: pre;    word-break: normal;    word-spacing: normal;}.prose :where(code):not(:where([class~=not-prose] *)) {    color: var(--tw-prose-code);    font-size: .875em;    font-weight: 600;}.prose :where(pre):not(:where([class~=not-prose] *)) {    background-color: transparent;    border-radius: 0.375rem;    color: currentColor;    font-size: .875em;    font-weight: 400;    line-height: 1.7142857;    margin: 0;    overflow-x: auto;    padding: 0;}.prose :where(pre code):not(:where([class~=not-prose] *)) {    background-color: transparent;    border-radius: 0;    border-width: 0;    color: inherit;    font-family: inherit;    font-size: inherit;    font-weight: inherit;    line-height: inherit;    padding: 0;}.\!whitespace-pre {    white-space: pre!important;}.overflow-y-auto {    overflow-y: auto;}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"/></head><body><div class="flex w-full items-center justify-center gap-1 border-b border-black/10 bg-gray-50 p-3 text-gray-500 dark:border-gray-900/50 dark:bg-gray-700 dark:text-gray-300">Model: GPT-4</div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">I have th following bit of R code:

```r
#' Linearly transform an \code{mle} object \code{x} by multiplying it
#' on the LHS by a matrix \code{A}.
#'
#' @param A a (non-random) matrix
#' @param x an \code{mle} object to linearly transform
#' @export
mle_linear_transform &lt;- function(A,x)
{
    mu &lt;- A %*% point(x)
    sigma &lt;- t(A) %*% point(x) %*% A

    res &lt;- structure(list(
        theta.hat=mu,
        info=MASS::ginv(sigma),
        sigma=sigma),
        class=unique(c("linear_transformed_mle",class(x))))
    attributes(res) &lt;- attributes(x)
    res
}
```

I think I would like to make this a multiplication using '%*%`.</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>It seems that you are already using the matrix multiplication operator <code>%*%</code> in your code. However, if you would like to clarify your question, please feel free to provide more context or explain the specific issue you are facing.</p><p>In your code, the matrix multiplication operator <code>%*%</code> is used in the following lines:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>r</span></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-r">mu <span class="hljs-operator">&lt;-</span> A <span class="hljs-operator">%*%</span> point<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span>
sigma <span class="hljs-operator">&lt;-</span> t<span class="hljs-punctuation">(</span>A<span class="hljs-punctuation">)</span> <span class="hljs-operator">%*%</span> point<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span> <span class="hljs-operator">%*%</span> A
</code></div></div></pre><p>These lines perform the matrix multiplication for the linear transformation. If you are looking for another kind of matrix multiplication or operation, please provide more information about your desired outcome.</p></div></div></div><div class="flex justify-between lg:block"></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">Let X be an \code{mle} object and \code{A} be a matrix. Then, I want to be able to write `A%*%x` and have it be equivalent to `mle_linear_transform(A,x)`.</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>To achieve this, you can define a custom S3 method for the <code>%*%</code> operator for a matrix and an <code>mle</code> object. Here's the code to do that:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>r</span></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-r"><span class="hljs-comment">#' Linearly transform an <span class="hljs-keyword">\code</span>{mle} object <span class="hljs-keyword">\code</span>{x} by multiplying it</span>
<span class="hljs-comment">#' on the LHS by a matrix <span class="hljs-keyword">\code</span>{A}.</span>
<span class="hljs-comment">#'</span>
<span class="hljs-comment">#' <span class="hljs-doctag">@param <span class="hljs-variable">A</span></span> a (non-random) matrix</span>
<span class="hljs-comment">#' <span class="hljs-doctag">@param <span class="hljs-variable">x</span></span> an <span class="hljs-keyword">\code</span>{mle} object to linearly transform</span>
<span class="hljs-comment">#' <span class="hljs-doctag">@export</span></span>
mle_linear_transform <span class="hljs-operator">&lt;-</span> <span class="hljs-keyword">function</span><span class="hljs-punctuation">(</span>A<span class="hljs-punctuation">,</span> x<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">{</span>
  mu <span class="hljs-operator">&lt;-</span> A <span class="hljs-operator">%*%</span> point<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span>
  sigma <span class="hljs-operator">&lt;-</span> t<span class="hljs-punctuation">(</span>A<span class="hljs-punctuation">)</span> <span class="hljs-operator">%*%</span> point<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span> <span class="hljs-operator">%*%</span> A

  res <span class="hljs-operator">&lt;-</span> structure<span class="hljs-punctuation">(</span><span class="hljs-built_in">list</span><span class="hljs-punctuation">(</span>
    theta.hat <span class="hljs-operator">=</span> mu<span class="hljs-punctuation">,</span>
    info <span class="hljs-operator">=</span> MASS<span class="hljs-operator">::</span>ginv<span class="hljs-punctuation">(</span>sigma<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>
    sigma <span class="hljs-operator">=</span> sigma<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>
    <span class="hljs-built_in">class</span> <span class="hljs-operator">=</span> unique<span class="hljs-punctuation">(</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">"linear_transformed_mle"</span><span class="hljs-punctuation">,</span> <span class="hljs-built_in">class</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>
  <span class="hljs-punctuation">)</span>
  <span class="hljs-built_in">attributes</span><span class="hljs-punctuation">(</span>res<span class="hljs-punctuation">)</span> <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">attributes</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span>
  res
<span class="hljs-punctuation">}</span>

<span class="hljs-comment">#' S3 method for matrix and <span class="hljs-keyword">\code</span>{mle} object multiplication</span>
<span class="hljs-comment">#'</span>
<span class="hljs-comment">#' <span class="hljs-doctag">@param <span class="hljs-variable">e1</span></span> a matrix</span>
<span class="hljs-comment">#' <span class="hljs-doctag">@param <span class="hljs-variable">e2</span></span> an <span class="hljs-keyword">\code</span>{mle} object</span>
<span class="hljs-comment">#' <span class="hljs-doctag">@export</span></span>
`%*%.matrix.mle` <span class="hljs-operator">&lt;-</span> <span class="hljs-keyword">function</span><span class="hljs-punctuation">(</span>e1<span class="hljs-punctuation">,</span> e2<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">{</span>
  mle_linear_transform<span class="hljs-punctuation">(</span>e1<span class="hljs-punctuation">,</span> e2<span class="hljs-punctuation">)</span>
<span class="hljs-punctuation">}</span>

<span class="hljs-comment"># Register the S3 method</span>
registerS3method<span class="hljs-punctuation">(</span><span class="hljs-string">"%*%"</span><span class="hljs-punctuation">,</span> signature<span class="hljs-punctuation">(</span>e1 <span class="hljs-operator">=</span> <span class="hljs-string">"matrix"</span><span class="hljs-punctuation">,</span> e2 <span class="hljs-operator">=</span> <span class="hljs-string">"mle"</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> `%*%.matrix.mle`<span class="hljs-punctuation">)</span>
</code></div></div></pre><p>Now, when you perform the operation <code>A %*% x</code>, where <code>A</code> is a matrix and <code>x</code> is an <code>mle</code> object, the custom S3 method <code>%*%.matrix.mle</code> will be called, which in turn calls the <code>mle_linear_transform</code> function.</p></div></div></div><div class="flex justify-between lg:block"></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">How is the Jacobian notated?</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>The Jacobian is a matrix that represents the first-order partial derivatives of a vector-valued function with respect to its input variables. It is named after the mathematician Carl Gustav Jacob Jacobi.</p><p>If you have a vector-valued function f: R^n → R^m, where f is a function that maps an n-dimensional input vector x = (x₁, x₂, ..., xₙ) to an m-dimensional output vector y = (y₁, y₂, ..., yₘ), then the Jacobian matrix J of f is an m x n matrix, with each element given by the partial derivative of the output component with respect to the input component:</p><p>J = [∂yᵢ/∂xⱼ] (i = 1, 2, ..., m; j = 1, 2, ..., n)</p><p>In notation, the Jacobian matrix is typically denoted by J or sometimes by the symbol ∇ (nabla), with subscripts to indicate the function and variables involved. For example, you might see it written as:</p><p>J(f) = [∂fᵢ/∂xⱼ]</p><p>or</p><p>∇f = [∂fᵢ/∂xⱼ]</p><p>The Jacobian matrix is crucial in many applications, including optimization, sensitivity analysis, and the study of dynamical systems.</p></div></div></div><div class="flex justify-between lg:block"></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">&gt; devtools::build(vignettes=F)
✔  checking for file ‘/home/spinoza/gh/algebraic.mle/DESCRIPTION’ ...
─  preparing ‘algebraic.mle’:
✔  checking DESCRIPTION meta-information ...
   Warning: /tmp/Rtmp3X9dVh/Rbuild1b3a8e589b9e74/algebraic.mle/man/print.summary_mle.Rd:5: unknown macro '\object'
   Warning: /tmp/Rtmp3X9dVh/Rbuild1b3a8e589b9e74/algebraic.mle/man/print.summary_mle.Rd:15: unknown macro '\object'
─  checking for LF line-endings in source and make files and shell scripts
─  checking for empty or unneeded directories
   Removed empty directory ‘algebraic.mle/tests/testthat’
   Omitted ‘LazyData’ from DESCRIPTION
─  building ‘algebraic.mle_0.9.0.tar.gz’</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>It seems you have shared the output of the <code>devtools::build()</code> function for an R package called <code>algebraic.mle</code>. This function is used to build a source package for your R project. From the output, it appears that the package was built successfully, with some minor warnings.</p><p>The warnings are related to the documentation in the <code>print.summary_mle.Rd</code> file:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>typescript</span></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-typescript"><span class="hljs-title class_">Warning</span>: <span class="hljs-regexp">/tmp/</span><span class="hljs-title class_">Rtmp3X9</span>dVh/<span class="hljs-title class_">Rbuild1</span>b3a8e589b9e74/algebraic.<span class="hljs-property">mle</span>/man/print.<span class="hljs-property">summary_mle</span>.<span class="hljs-property">Rd</span>:<span class="hljs-number">5</span>: <span class="hljs-built_in">unknown</span> macro <span class="hljs-string">'\object'</span>
<span class="hljs-title class_">Warning</span>: <span class="hljs-regexp">/tmp/</span><span class="hljs-title class_">Rtmp3X9</span>dVh/<span class="hljs-title class_">Rbuild1</span>b3a8e589b9e74/algebraic.<span class="hljs-property">mle</span>/man/print.<span class="hljs-property">summary_mle</span>.<span class="hljs-property">Rd</span>:<span class="hljs-number">15</span>: <span class="hljs-built_in">unknown</span> macro <span class="hljs-string">'\object'</span>
</code></div></div></pre><p>These warnings are caused by the use of the unknown macro <code>\object</code> in the documentation. To resolve these warnings, you can replace the <code>\object</code> macro with the appropriate macro (e.g., <code>\code</code>, <code>\link</code>, or <code>\samp</code>). Review the documentation for the <code>print.summary_mle</code> function to ensure that you're using the correct macro for the context.</p><p>Apart from these warnings, the package seems to have been built successfully, and you should now have a <code>.tar.gz</code> file (<code>algebraic.mle_0.9.0.tar.gz</code>) that contains your package source code. You can now distribute this file, use it to install the package locally, or submit it to CRAN or other package repositories.</p></div></div></div><div class="flex justify-between lg:block"></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">I get this error:

lines 403-405 (exponential-mle.Rmd) 
Error in pred.mle(x = rate.hat, samp = rexp, sup = function(x) x &gt; 0) : 
  object 'thetas' not found
Calls: &lt;Anonymous&gt; ... eval_with_user_handlers -&gt; eval -&gt; eval -&gt; pred -&gt; pred.mle


Here's pred.mle:

pred.mle &lt;- function(x, samp, alpha = 0.05) {
    N &lt;- 10000
    theta &lt;- point(x)
    sigma &lt;- vcov(x)

    if (length(theta) == 1) {
        thetas &lt;- rnorm(N, theta, sd = sqrt(sigma))
    } else {
        thetas &lt;- rmvnorm(N, theta, sigma)
    }

    ts &lt;- sort(sapply(thetas, function(theta) samp(1, theta)))
    # predictive interval for T
    pi &lt;- matrix(c(
        mean(ts),
        quantile(ts, c(alpha / 2, 1 - alpha / 2))
    ), nrow = 1)
    colnames(pi) &lt;- c("mean", "lower", "upper")
    pi
}
</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>The error message you shared indicates that the object 'thetas' is not found when calling the <code>pred.mle</code> function. This error is due to the fact that the variable <code>thetas</code> is not visible outside the scope of the <code>if</code> and <code>else</code> blocks.</p><p>To resolve the issue, you should initialize the <code>thetas</code> variable before the <code>if</code> statement. Here's the modified <code>pred.mle</code> function:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>R</span></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-R">pred.mle <span class="hljs-operator">&lt;-</span> <span class="hljs-keyword">function</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">,</span> samp<span class="hljs-punctuation">,</span> alpha <span class="hljs-operator">=</span> <span class="hljs-number">0.05</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">{</span>
    N <span class="hljs-operator">&lt;-</span> 10000
    theta <span class="hljs-operator">&lt;-</span> point<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span>
    sigma <span class="hljs-operator">&lt;-</span> vcov<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span>

    <span class="hljs-comment"># Initialize thetas variable</span>
    thetas <span class="hljs-operator">&lt;-</span> <span class="hljs-literal">NULL</span>

    <span class="hljs-keyword">if</span> <span class="hljs-punctuation">(</span><span class="hljs-built_in">length</span><span class="hljs-punctuation">(</span>theta<span class="hljs-punctuation">)</span> <span class="hljs-operator">==</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">{</span>
        thetas <span class="hljs-operator">&lt;-</span> rnorm<span class="hljs-punctuation">(</span>N<span class="hljs-punctuation">,</span> theta<span class="hljs-punctuation">,</span> sd <span class="hljs-operator">=</span> <span class="hljs-built_in">sqrt</span><span class="hljs-punctuation">(</span>sigma<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>
    <span class="hljs-punctuation">}</span> <span class="hljs-keyword">else</span> <span class="hljs-punctuation">{</span>
        thetas <span class="hljs-operator">&lt;-</span> rmvnorm<span class="hljs-punctuation">(</span>N<span class="hljs-punctuation">,</span> theta<span class="hljs-punctuation">,</span> sigma<span class="hljs-punctuation">)</span>
    <span class="hljs-punctuation">}</span>

    ts <span class="hljs-operator">&lt;-</span> sort<span class="hljs-punctuation">(</span>sapply<span class="hljs-punctuation">(</span>thetas<span class="hljs-punctuation">,</span> <span class="hljs-keyword">function</span><span class="hljs-punctuation">(</span>theta<span class="hljs-punctuation">)</span> samp<span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> theta<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>
    <span class="hljs-comment"># predictive interval for T</span>
    <span class="hljs-built_in">pi</span> <span class="hljs-operator">&lt;-</span> matrix<span class="hljs-punctuation">(</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span>
        mean<span class="hljs-punctuation">(</span>ts<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>
        quantile<span class="hljs-punctuation">(</span>ts<span class="hljs-punctuation">,</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span>alpha <span class="hljs-operator">/</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span> <span class="hljs-operator">-</span> alpha <span class="hljs-operator">/</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>
    <span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> nrow <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span>
    colnames<span class="hljs-punctuation">(</span><span class="hljs-built_in">pi</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">"mean"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"lower"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"upper"</span><span class="hljs-punctuation">)</span>
    <span class="hljs-built_in">pi</span>
<span class="hljs-punctuation">}</span>
</code></div></div></pre><p>By initializing the <code>thetas</code> variable before the <code>if</code> statement, you ensure that it's visible in the scope of the entire function, and the error should be resolved.</p></div></div></div><div class="flex justify-between lg:block"></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">#' Linearly transform an \code{mle} object \code{x} by multiplying it
#' on the LHS by a matrix \code{A}.
#'
#' @param A a (non-random) matrix
#' @param x an \code{mle} object to linearly transform
#' @return a \code{mle_linear_transform} object
#' @export
mle_linear_transform &lt;- function(A,x)
{
    t.theta.hat &lt;- A %*% point(x)
    t.sigma &lt;- t(A) %*% point(x) %*% A

    # the origional observations are `nobs(x)`, which is how `x` was
    # fitted as an mle object.  The transformed observations are
    # `t.obs` are the observations that were needed to yield an
    # mle `A %*% x`. NOTE: TEST THIS OUT!
    t.obs &lt;- lapply(obs(x), function(o) A %*% o)

    # loglike(x) retrieves the (usually precomputed during the fitting
    # procedure) value of the log-likelihood function evaluated at `point(x)`.
    # NOTE: TEST THIS OUT!
    t.loglike &lt;- loglike(x) + log(abs(det(A)))

    t.score &lt;- NULL
    
    mle(
        theta.hat = t.theta.hat,
        loglike = t.loglike,
        score = t.score,
        sigma = t.sigma,
        info = ginv(t.sigma),
        obs = t.obs,
        nobs = nobs(x),
        superclasses = c("mle_linear_transform"))
}


#' Method for matrix and \code{mle} object multiplication
#'
#' @param e1 a matrix
#' @param e2 an \code{mle} object
#' @export
`%*%.matrix.mle` &lt;- function(e1, e2) {
  mle_linear_transform(e1, e2)
}

Error in matrix(2) %*% rate.hat : 
  requires numeric/complex matrix/vector arguments
Calls: &lt;Anonymous&gt; ... withVisible -&gt; eval_with_user_handlers -&gt; eval -&gt; eval</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>The error you're encountering is due to attempting to multiply a matrix with an <code>mle</code> object directly using the <code>%*%</code> operator. This is not supported by default in R. However, you've defined a custom method for this operation called <code>%*%.matrix.mle</code>. To make sure R uses the custom method you defined, you need to register it as an S3 method.</p><p>Please add the following line of code after the definition of <code>%*%.matrix.mle</code> to register it as an S3 method:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>R</span></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-R">registerS3method<span class="hljs-punctuation">(</span><span class="hljs-string">"%*%"</span><span class="hljs-punctuation">,</span> signature<span class="hljs-punctuation">(</span>e1 <span class="hljs-operator">=</span> <span class="hljs-string">"matrix"</span><span class="hljs-punctuation">,</span> e2 <span class="hljs-operator">=</span> <span class="hljs-string">"mle"</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> `%*%.matrix.mle`<span class="hljs-punctuation">)</span>
</code></div></div></pre><p>After registering the custom method, you should be able to use the <code>%*%</code> operator with a matrix and an <code>mle</code> object without encountering the error.</p><p>In case the error persists, please double-check that the <code>rate.hat</code> object is actually an <code>mle</code> object and that you have loaded all the required packages and dependencies for your code.</p></div></div></div><div class="flex justify-between lg:block"></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 dark:bg-gray-800"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap">1: In assign(paste(genname, class, sep = "."), method, envir = table) :
  only the first element is used as variable name
2: In rbind(.getNamespaceInfo(ns, "S3methods"), c(generic, class, method,  :
  number of columns of result is not a multiple of vector length (arg 2)</div></div></div></div></div><div class="group w-full text-gray-800 dark:text-gray-100 border-b border-black/10 dark:border-gray-900/50 bg-gray-50 dark:bg-[#444654]"><div class="text-base gap-4 md:gap-6 md:max-w-2xl lg:max-w-xl xl:max-w-3xl p-4 md:py-6 flex lg:px-0 m-auto"><div class="relative flex w-[calc(100%-50px)] flex-col gap-1 md:gap-3 lg:w-[calc(100%-115px)]"><div class="flex flex-grow flex-col gap-3"><div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>The warnings you are encountering are likely due to the incorrect registration of the S3 method. It seems like there might be an issue with the method signature or the registration function.</p><p>First, make sure that the <code>mle</code> object in the signature is the correct class name for your <code>mle</code> objects. If you're using a different package or class, you may need to adjust the signature accordingly.</p><p>To avoid any potential issues, I suggest you use the <code>setMethod</code> function from the <code>methods</code> package to register the S3 method. Here's an updated version of your code:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>R</span></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-R"><span class="hljs-comment">#' Method for matrix and <span class="hljs-keyword">\code</span>{mle} object multiplication</span>
<span class="hljs-comment">#'</span>
<span class="hljs-comment">#' <span class="hljs-doctag">@param <span class="hljs-variable">e1</span></span> a matrix</span>
<span class="hljs-comment">#' <span class="hljs-doctag">@param <span class="hljs-variable">e2</span></span> an <span class="hljs-keyword">\code</span>{mle} object</span>
<span class="hljs-comment">#' <span class="hljs-doctag">@export</span></span>
`%*%` <span class="hljs-operator">&lt;-</span> <span class="hljs-keyword">function</span><span class="hljs-punctuation">(</span>e1<span class="hljs-punctuation">,</span> e2<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-built_in">UseMethod</span><span class="hljs-punctuation">(</span><span class="hljs-string">"%*%"</span><span class="hljs-punctuation">)</span>
<span class="hljs-punctuation">}</span>

<span class="hljs-comment">#' <span class="hljs-doctag">@export</span></span>
`%*%.matrix.mle` <span class="hljs-operator">&lt;-</span> <span class="hljs-keyword">function</span><span class="hljs-punctuation">(</span>e1<span class="hljs-punctuation">,</span> e2<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">{</span>
  mle_linear_transform<span class="hljs-punctuation">(</span>e1<span class="hljs-punctuation">,</span> e2<span class="hljs-punctuation">)</span>
<span class="hljs-punctuation">}</span>

<span class="hljs-comment"># Register the S3 method</span>
setMethod<span class="hljs-punctuation">(</span><span class="hljs-string">"%*%"</span><span class="hljs-punctuation">,</span> signature<span class="hljs-punctuation">(</span>e1 <span class="hljs-operator">=</span> <span class="hljs-string">"matrix"</span><span class="hljs-punctuation">,</span> e2 <span class="hljs-operator">=</span> <span class="hljs-string">"mle"</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> `%*%.matrix.mle`<span class="hljs-punctuation">)</span>
</code></div></div></pre><p>This code defines a generic <code>%*%</code> function using <code>UseMethod</code>, and then registers the <code>%*%.matrix.mle</code> method using the <code>setMethod</code> function. Now, when you call <code>%*%</code> with a matrix and an <code>mle</code> object, R should use the <code>%*%.matrix.mle</code> method, and you should not see any warnings or errors.</p><p>Make sure to load the <code>methods</code> package by calling <code>library(methods)</code> before registering the method. Also, ensure that the class names in the signature match the actual class names used in your code.</p></div></div></div><div class="flex justify-between lg:block"></div></div></div></div></body></html>